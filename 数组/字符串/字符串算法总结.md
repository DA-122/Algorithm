# 字符串算法
## 1.KMP算法：
### **算法步骤**：
1. 给定一模式串P和一搜索串S，先根据模式串P求出部分匹配表(Partial Match Table);

2. 然后字符串P和S开始字符匹配，S中字符与P中字符不匹配时，模式串P向后移动k位（永不回退S，只是把P移动到正确位置继续匹配），移动位数公式：

$$ 移动位数 = 已匹配字符数 - 对应的部分匹配值 $$

3. 重复2直到匹配结束。


### **部分匹配表**：

前缀：除最后一个字符外，字符串中所有字符的组合(必须包含第一个字符)；

后缀：除了第一个字符外，字符串中所有字符的组合(必须包含最后一个字符)；

部分匹配表值:以当前字符为最后一个字符，子串中前后缀共有元素最大长度(最长相等前后缀)。

举例：
<div align=center><img src="./KMP算法/部分匹配表.png"></div>

    - "A"的前缀和后缀都为空集，共有元素长度为0；
    - "AB"的前缀为[A]，后缀为[B]，共有元素长度为0；
    - "ABC"的前缀为[A,AB]，后缀[BC,C]，共有元素长度为0；
    - "ABCD"的前缀为[A,AB,ABC]，后缀为[BCD,CD,D]，共有元素长度为0；
    －"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
    －"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；
    －"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。
### **代码实现**

<a href = 'https://blog.csdn.net/weixin_46503238/article/details/125022699?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-125022699-blog-80094101.235^v32^pc_relevant_default_base&spm=1001.2101.3001.4242.1&utm_relevant_index=3'> 参考文献 </a>


```
// 第一种写法，实现上述理论，这里的i ∈ [1,n]  j ∈ [1,m]
/*  next数组初始化
 *  next[i]表示模式串P[1,i]中相同前后缀的最长长度，标志了前缀所能匹配的最大位置。
 *  j指向当前i匹配的最大前缀的末尾
 *  当模式串扫描(i = i+1)时,先判断能否继续沿着当前前缀拓展,
 *  (1).P[j+1] == P[i], 如果能拓展，j++，next[i] = j, 开始下一轮扫描 i++;
 *  (2).P[j+1] != P[i], j = next[j](跳到能跳的地方去),继续判断,直到j++或者j=0为止,next[i] == j。
 */


/* 模式串匹配
 * i指向搜索串,j指向模式串
 * S[i]与P[j]进行字符对比，相等j++,不等j = next[j],直到j为0或者S[i] = P[j] 当 j = m时说明找到了最终结果
 *
 *
 */


//  注意next[] 与字符数组中的位置差1
    public int Kmp(String S, String P){
        int n = S.length();
        int m = P.length();
        if(n < m){
            return -1;
        }
        int [] next = new int[m+1];
        char[] p = P.toCharArray();
        char[] s = S.toCharArray();
        for(int i = 2, j = 0; i <= m; i++){
            while(j!=0 && p[i-1] != p[j])
                j = next[j];
            if(p[i-1] == p[j])
                j++;
            next[i] = j;
        }
        for(int i = 1, j = 0; i <= n; i++){
            // 不匹配
            while(j!=0 && s[i-1] != p[j]){
                j = next[j];
            }
            if(s[i-1] == p[j])
                j++;
            if(j==m)
                return i-m;
        }
        return -1;
    }


    public int Kmp(String haystack, String needle) {
        int n = haystack.length();
        int m = haystack.length();
        if(n<m){
            return -1;
        }
        char[] p = needle.toCharArray();
        // 部分匹配数组
        int[] next = new int[m];
        next[0] = -1;
        for(int i=1,j=-1;i<m;i++){
            while(j>-1&&p[i]!=p[j+1]){
                j=next[j];
            }
            if(p[i]==p[j+1]){
                j++;
            }
            next[i]=j;
        }
        for(int i=0,j=-1;i<n;i++){
            while(j>-1&&haystack.charAt(i)!=needle.charAt(j+1)){
                j=next[j];
            }
            if(haystack.charAt(i)==needle.charAt(j+1)){
                j++;
                if(j==m-1){
                    return i-m+1;
                }
            }
        }
        return -1;
    }

```

    
## 2.Rabin-karp算法
## 3.字典序问题