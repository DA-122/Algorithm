# 二叉树
## 一.二叉树的数学性质
## 二.先序遍历
## 三.中序遍历
### 1.中序遍历
### 2.Morris遍历
Morris遍历是一种**常数空间复杂度**的遍历方法，其本质是<u>**中序线索二叉树**</u>。

**线索二叉树定义**：对于任意一个节点数为N的二叉树，其NULL指针的数量为N+1，线索二叉树就是利用了这些被浪费的NULL指针的数据结构。将一颗普通二叉树中任一节点的空右孩子指针指向中序遍历的后继节点，空左孩子指针指向中序遍历的前继节点，就构成了一颗中序线索二叉树。

**Morris中序遍历**：关键在于寻找当前节点的前驱节点，寻找下一点通过转移right指针指向的位置完成。
* 如果当前节点没有左子树，遍历该节点，然后跳转到当前节点右子树。
* 如果当前节点有左子树，前驱节点一定在左子树上，可以延左子树向右行走，找到当前节点的前驱节点。
    * 如果前驱节点没有右子树，就将前驱节点的right指针指向当前节点；
    * 如果前驱节点右子树为当前节点，说明前驱节点已经被遍历过并被修改了right指针，此时应该将前驱右孩子设置为空，遍历当前节点，并跳转到当前节点的右子树。

上述过程代码如下：
```
TreeNode *cur = root, *pre = nullptr;
while (cur) {
    // cur没有左节点，遍历该节点并跳转到当前节点右子树
    if (!cur->left) {
        // ...遍历 cur
        cur = cur->right;
        continue;
    }
    // 有左节点，前驱指向左子树并沿右子树行走，找到前驱节点
    pre = cur->left;
    while (pre->right && pre->right != cur) {
        pre = pre->right;
    }
    // 前驱节点没有右孩子
    if (!pre->right) {
        pre->right = cur;
        cur = cur->left;
    // 前驱节点右孩子就是当前节点
    } else {
        pre->right = nullptr;
        // ...遍历 cur
        cur = cur->right;
    }
}
```

## 四.后序遍历
## 五.层次遍历（广度优先搜索）
## 六.深度优先搜索
## 七.恢复二叉树
## 八.二叉搜索树
