# 单调栈
## 一、什么是单调栈
        单调栈是栈数据结构的一种变形，在满足栈先进后出（FILO）的条件下，还要满足栈内元素遵循单调性。比如从栈底到栈顶元素保持递增的单调递增栈。
## 二、如何维护单调栈
        以维护一个单调递增栈为例。当插入一个新元素时，为了维护栈内的单调性，我们将该元素与栈顶元素进行比较，若不满足单调性，就将栈顶元素弹出，不断重复，直到栈空或者满足单调性为止，最后再将该元素塞入栈顶。

写成代码就是这样子：
```````````
    // nums是原数组,单调栈中只存储下标，通过nums[index]来获取元素
    // 保持栈内单调递减
    int[] res = new int[nums.length];
    Deque<Integer> stack = new ArrayDeque<>();
    stack.push(0);
    for(int i = 1; i < nums.length;i++){
        if(nums[i] <= nums[stack.peek()]){
            stack.push(i);
        }else{
            while(!stack.isEmpty()&&nums[i]>nums[stack.peek()]){
                res[stack.peek()]=i-stack.peek();
                stack.pop();
            }
            stack.push(i);
        }
    }

``````````````````````````````

## 三、如何维护单调栈

单调栈最经典的应用，就是在一个数列里寻找距离元素最近的比其大/小的元素位置。比如以下问题：

    对数列中的每个元素，寻找其左侧第一个比它大的元素位置。

显而易见的，我们可以遍历每个元素，然后从其位置往左寻找，这样的暴力做法时间复杂度是$O(N^2)$,但单调栈可以将时间复杂度降到$O(N)$。

我们只需从右往左遍历数列，依次将元素加入单调栈中，维护一个从栈底到栈顶递减的单调栈；

当某个元素被从栈内弹出时，代表它遇到了一个比它更大的元素，因为是从右往左遍历，所以该元素就是第一个比它大的元素，即所求。

如果最后仍在栈内，则说明该元素左侧没有比它更大的元素。

遍历的时间复杂度是 $O(N)$，每个元素最多被加入单调栈一次、弹出来一次，所以总时间复杂度是 $O(N)$。

对于要求解的这类问题，我们可以列一个简单的表格――

|求解的问题 | 遍历方向 | 维护单调性（栈底->栈顶）|
|----------|---------|----------------------|
|左侧第一个更大| 从右到左   |   单调递减 |
|左侧第一个更小| 从右到左	|   单调递增 |
|右侧第一个更大| 从左到右	|   单调递减 |
|右侧第一个更小| 从左到右	|   单调递增 |

